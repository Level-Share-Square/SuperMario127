[gd_resource type="Shader" format=2]

[resource]
code = "shader_type canvas_item;

uniform vec4 color : hint_color;
uniform sampler2D noise_texture_1;
uniform sampler2D noise_texture_2;
uniform sampler2D noise_texture_3;

uniform vec2 noise_scale_1;
uniform vec2 noise_offset_1;
uniform vec2 noise_speed_1;

uniform vec2 noise_scale_2;
uniform vec2 noise_offset_2;
uniform vec2 noise_speed_2;

uniform vec2 noise_scale_3;
uniform vec2 noise_offset_3;
uniform vec2 noise_speed_3;

uniform float x_size = 600.0;

float random (vec2 uv) {
    return fract(sin(dot(uv.xy, vec2(12.9898,78.233))) * 43758.5453123);
}


float sine(vec2 uv_coords, float time, float arg1, float arg2) {
	return sin((uv_coords.x * arg1 * (x_size / 1500.0f)) + time * arg2);
}

void fragment() {
	vec4 base = texture(TEXTURE, UV);
	base *= color;
	base.rgb /= vec3(2);
	
	vec2 noise_uv_1 = (UV * noise_scale_1) + (noise_offset_1/vec2(512)) + (noise_speed_1 * TIME);
	vec4 noise_1 = texture(noise_texture_1, noise_uv_1);
	
	vec2 noise_uv_2 = (UV * noise_scale_2) + (noise_offset_2/vec2(32)) + (noise_speed_2 * TIME);
	vec4 noise_2 = texture(noise_texture_2, noise_uv_2);
	
	vec2 noise_uv_3 = (UV * noise_scale_3) - (noise_offset_3/vec2(128)) + (noise_speed_3 * TIME);
	vec4 noise_3 = texture(noise_texture_3, noise_uv_3);
	
	vec3 mix1 = noise_1.rgb/vec3(7.5);
	vec3 mix2 = noise_2.rgb/vec3(4.5);
	vec3 mix3 = noise_3.rgb/vec3(10);
	
	base.rgb = base.rgb + mix1 + mix2 - mix3;
//	base.rgb = base.rgb + mix3*vec3(8);
	
	float final_sine = sine(UV, TIME / 8.0f, 10.5f, 1.0f) * sine(UV, TIME / 8.0f, 7.5f, 5.5f) * sine(UV, TIME / 8.0f, 15.5f, 1.0f);
	float sine_height = (final_sine / 20.0f) + 0.25f;
	if (UV.y < sine_height) {
		base.a = 0.0;
	} else {
		float gradient_pos = round(((UV.y * 2.0) - (sine_height * 2.0)) * 12.0) / 6.0;
		float mix_amount = clamp(1.0 - gradient_pos, 0.0, .6);
		base.rgb = mix(base.rgb, (color.rgb+vec3(.75))/1.5, mix_amount);
	}
	
	COLOR = base;
}"
