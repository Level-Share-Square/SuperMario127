[gd_resource type="Shader" format=2]

[resource]
code = "shader_type canvas_item;

uniform vec4 color : hint_color;
uniform sampler2D noise_texture_1;
uniform sampler2D noise_texture_2;
uniform sampler2D noise_texture_3;

uniform vec2 noise_scale_1;
uniform vec2 noise_offset_1;
uniform vec2 noise_speed_1;

uniform vec2 noise_scale_2;
uniform vec2 noise_offset_2;
uniform vec2 noise_speed_2;

uniform vec2 noise_scale_3;
uniform vec2 noise_offset_3;
uniform vec2 noise_speed_3;

uniform float x_size = 600.0;

float random (vec2 uv) {
    return fract(sin(dot(uv.xy, vec2(12.9898,78.233))) * 43758.5453123);
}


float sine(vec2 uv_coords, float time, float arg1, float arg2) {
	return sin((uv_coords.x * arg1 * (x_size / 20.0f)) + time * arg2);
}

float get_size() {
	return x_size/1500.0f;
}

void fragment() {
	vec4 base = texture(TEXTURE, UV);
	base *= color;
	base.rgb /= vec3(2);
	
	//retooled as a distortion map
	vec2 noise_uv_3 = (UV * noise_scale_3) - (noise_offset_3/vec2(128)) + (noise_speed_3 * TIME);
	vec4 noise_3 = texture(noise_texture_3, noise_uv_3);
	
	vec2 noise_uv_1 = (UV * noise_scale_1) + (noise_offset_1/vec2(512)) + (noise_speed_1 * TIME);
	vec4 noise_1 = texture(noise_texture_1, noise_uv_1);
	
	vec2 noise_uv_2 = (UV * noise_scale_2) + (noise_offset_2/vec2(32)) + (noise_speed_2 * TIME);
	vec4 noise_2 = texture(noise_texture_2, noise_uv_2+(noise_3.xy/(16.0 * ((1.0-UV.y)/2.0+.5))));
	
	vec3 mix1 = noise_1.rgb/vec3(8.5);
	vec3 mix2 = noise_2.rgb/vec3(4.5);
	
//	base.rgb = base.rgb + mix1 + mix2;
	
	float s1 = sine(UV, TIME, 1.0f, 1.5f) * sin(TIME*1.5);
	float s2 = sine(UV, TIME+1.5707f, 1.0f, 1.5f) * sin(TIME*1.5+1.5707f);
	float s3 = sine(UV, TIME, 4.0f, 3.0f);
	
	float final_sine = ((s1 * s2 * 2.0f) + (s3/2.0))*1.75;
	float sine_height = (final_sine / 20.0f) + 0.25f;
	if (UV.y < sine_height) {
		base.a = 0.0;
	} else {
		float gradient_pos = (((UV.y * 1.0) - (sine_height * 1.0)) * 24.0) / 8.0;
		vec4 gradient_color = texture(noise_texture_1, vec2(1.0-gradient_pos+(noise_3.r/4.0), 0));
		base.rgb = mix(base.rgb, vec3(1.0), gradient_color.rgb) + (mix2.rgb);
		base.a = clamp((1.0-UV.y)*1.75, 0, 1.0)
	}
	
	COLOR = base;
}"
