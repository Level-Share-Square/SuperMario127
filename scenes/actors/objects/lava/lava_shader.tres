[gd_resource type="Shader" format=2]

[resource]
code = "shader_type canvas_item;

uniform vec4 color : hint_color;
uniform sampler2D noise_texture_1;
uniform sampler2D noise_texture_2;
uniform sampler2D noise_texture_3;

uniform vec2 noise_scale_1;
uniform vec2 noise_offset_1;
uniform vec2 noise_speed_1;

uniform vec2 noise_scale_2;
uniform vec2 noise_offset_2;
uniform vec2 noise_speed_2;

uniform vec2 noise_scale_3;
uniform vec2 noise_offset_3;
uniform vec2 noise_speed_3;

uniform float x_size = 600.0;

float random (vec2 uv) {
    return fract(sin(dot(uv.xy, vec2(12.9898,78.233))) * 43758.5453123);
}


float sine(vec2 uv_coords, float time, float arg1, float arg2) {
	return sin((uv_coords.x * arg1 * (x_size / 20.0f)) + time * arg2);
}

float get_size() {
	return x_size/1500.0f;
}

void fragment() {
	vec4 base = texture(TEXTURE, UV);
	base *= color;
	base.rgb /= vec3(2);
	
	//retooled as a distortion map
	vec2 noise_uv_3 = (UV * noise_scale_3) - (noise_offset_3/vec2(128)) + (noise_speed_3 * TIME);
	vec4 noise_3 = texture(noise_texture_3, noise_uv_3);
	
	vec2 noise_uv_1 = (UV * noise_scale_1) + (noise_offset_1/vec2(512)) + (noise_speed_1 * TIME);
	vec4 noise_1 = texture(noise_texture_1, noise_uv_1+noise_3.xy/12.0);
	
	vec2 noise_uv_2 = (UV * noise_scale_2) + (noise_offset_2/vec2(32)) + (noise_speed_2 * TIME);
	vec4 noise_2 = texture(noise_texture_2, noise_uv_2+((noise_1.xy*2.0)/(12.0)));
	
	vec3 mix1 = noise_1.rgb/vec3(4.0);
	vec3 mix2 = noise_2.rgb/vec3(4.0);
	
	base.rgb += round(((mix2+vec3(.1)) * color.rgb)*40.0)/40.0;
	
	COLOR = base;
}"
